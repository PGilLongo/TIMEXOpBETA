<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NAVEGADOR</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .hud {
      transform: scale(0.9);
      transform-origin: top left;
      position: absolute; z-index: 9999;
      top: 12px; left: 12px;
      background: rgba(255,255,255,.92);
      padding: 10px 12px; border-radius: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.15);
    }

    .row {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap: nowrap;
      white-space: nowrap;
    }

    button { cursor:pointer; font-size: 11.5px; }

    .file-btn {
      display:inline-flex;
      align-items:center;
      padding: 2px 10px;
      border: 1px solid rgba(0,0,0,.25);
      border-radius: 6px;
      background: #fff;
      cursor: pointer;
      user-select: none;
      font-size: 11.5px;
      line-height: 24px;
      white-space: nowrap;
    }

    #kmzFile { display:none; }

    .leaflet-control-layers {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: 12px;
      border-radius: 10px;
    }

    .follow {
      display:flex;
      align-items:center;
      gap:4px;
      white-space: nowrap;
    }
  
    .search-wrap{
      margin-top:8px;
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap: wrap;
    }
    #searchBox{
      width: 260px;
      max-width: 70vw;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,.25);
      font-size: 11.5px;
      outline: none;
    }
    #clearRouteBtn{
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,.25);
      background: #fff;
    }
    #results{
      margin-top:6px;
      max-height: 220px;
      overflow:auto;
      border: 1px solid rgba(0,0,0,.15);
      border-radius: 10px;
      background: rgba(255,255,255,.98);
      display:none;
    }
    .result-item{
      padding: 8px 10px;
      cursor:pointer;
      border-bottom: 1px solid rgba(0,0,0,.06);
      font-size: 11.5px;
    }
    .result-item:last-child{ border-bottom: none; }
    .result-item:hover{ background: rgba(0,0,0,.04); }
    .muted{ color: rgba(0,0,0,.6); font-size: 12px; }

    .icon-wrap{
      margin-top:8px;
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap: wrap;
    }
    #kmzSelect{
      max-width: 46vw;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,.25);
      background:#fff;
      font-size: 11.5px;
    }
    #iconUrl{
      width: 320px;
      max-width: 70vw;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,.25);
      font-size: 11.5px;
      outline: none;
    }
    #applyIconBtn, #resetIconBtn{
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,.25);
      background: #fff;
    }
    /* Evita m√°rgenes raros en algunos iconos */
    .me-icon-wrap{
      margin-top:6px;
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap: wrap;
    }

    .size-btn{
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,.25);
      background: #fff;
      cursor: pointer;
      font-size: 16px;
      line-height: 16px;
    }

    .kmz-img-icon{
      border-radius: 50%;
      overflow: hidden;
    }

  
    /* --- Minimizar panel (HUD) --- */
    .hud-header{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap:10px;
    }
    .hud-header .row{ flex: 1 1 auto; }
    .hud-toggle{
      border: 1px solid rgba(0,0,0,.25);
      background: #fff;
      border-radius: 8px;
      padding: 2px 8px;
      font-size: 14px;
      line-height: 18px;
      cursor: pointer;
      user-select: none;
    }
    .hud.minimized{
      padding: 8px 10px;
    }
    .hud.minimized .hud-body{
      display:none;
    }


  
    /* Asegura transparencia en iconos (png con alpha) */
    .leaflet-marker-icon.kmz-img-icon,
    .leaflet-marker-icon.me-img-icon{
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
    }

    /* Marcador "yo" rotatable (flecha) */
    .me-rot-wrap{
      width: 18px;
      height: 18px;
      transform-origin: 50% 50%;
      will-change: transform;
      pointer-events: none;
    }
    .me-rot-arrow{
      position: absolute;
      left: 50%;
      top: 50%;
      width: 0;
      height: 0;
      transform: translate(-50%, -60%);
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-bottom: 10px solid #2b6cff;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,.35));
    }
    .me-rot-dot{
      position: absolute;
      left: 50%;
      top: 50%;
      width: 14px;
      height: 14px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: #2b6cff;
      border: 3px solid #fff;
      box-shadow: 0 2px 10px rgba(0,0,0,.35);
    }
    .me-rot-img{
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      overflow: hidden;
      background: transparent;
    }
    .me-rot-img img{
      display:block;
      background: transparent;
    }

</style>
</head>
<body>
  <div class="hud" id="hud">
    <div class="hud-header">
      <div class="row">
      <button id="recenterBtn" type="button">Centrarme</button>
      <button id="fitAllBtn" type="button">Ver todo</button>

      <label class="follow">
        <input id="followChk" type="checkbox" checked />
        seguirme
      </label>

      <button id="chooseFilesBtn" type="button" class="file-btn">
        Elegir archivos
      </button>
    </div>
      <button id="hudToggleBtn" class="hud-toggle" type="button" aria-label="Minimizar panel" title="Minimizar / expandir">‚ñæ</button>
    </div>

    <div class="hud-body">
      <div class="search-wrap">
      <input id="searchBox" type="search" placeholder="Buscar punto por nombre‚Ä¶" autocomplete="off" />
      <button id="clearRouteBtn" type="button" title="Quitar la ruta actual">Quitar ruta</button>
      <span id="searchHint" style="display:none"></span>
    </div>
    <div id="results" aria-label="Resultados de b√∫squeda"></div>

    <div class="icon-wrap">
      <select id="kmzSelect" title="Selecciona el KMZ al que aplicar el icono" disabled>
        <option value="">KMZ: (ninguno)</option>
      </select>
      <input id="iconUrl" type="url" placeholder="URL directa del icono (png/svg/webp)‚Ä¶" inputmode="url" autocomplete="off" />
      <button id="applyIconBtn" type="button" title="Aplicar icono al KMZ seleccionado">Aplicar icono</button>
      <button id="resetIconBtn" type="button" title="Volver al punto de color">Punto</button>
            <button id="deleteKmzBtn" type="button" title="Borrar KMZ seleccionado">üóëÔ∏è Borrar KMZ</button>
<button id="sizeDownBtn" type="button" class="size-btn" title="Icono m√°s peque√±o">‚àí</button>
      <button id="sizeUpBtn" type="button" class="size-btn" title="Icono m√°s grande">+</button>
    </div>

    
    <div class="me-icon-wrap">
      <input id="meIconUrl" type="url" placeholder="Icono ubicaci√≥n (URL)‚Ä¶" inputmode="url" autocomplete="off" />
      <button id="applyMeIconBtn" type="button" title="Aplicar icono a tu ubicaci√≥n">Aplicar</button>
      <button id="meSizeDownBtn" type="button" class="size-btn" title="Icono ubicaci√≥n m√°s peque√±o">‚àí</button>
      <button id="meSizeUpBtn" type="button" class="size-btn" title="Icono ubicaci√≥n m√°s grande">+</button>
    </div>
    </div>

<input type="file" id="kmzFile" accept=".kmz" multiple />
    <small id="status" style="display:none"></small>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tmcw/togeojson@5.6.2/dist/togeojson.umd.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.js"></script>

  <script>
    const statusEl = document.getElementById("status");
    const followChk = document.getElementById("followChk");
    const recenterBtn = document.getElementById("recenterBtn");
    const fitAllBtn = document.getElementById("fitAllBtn");
    const kmzInput = document.getElementById("kmzFile");
    const chooseFilesBtn = document.getElementById("chooseFilesBtn");
    const hudEl = document.getElementById("hud");
    const hudToggleBtn = document.getElementById("hudToggleBtn");

    // -----------------------------
    // Persistencia (KMZ + iconos)
    // -----------------------------
    const KMZ_DB_NAME = "kmz_navegador_db";
    const KMZ_DB_VERSION = 1;
    const KMZ_STORE = "kmzFiles";
    const LS_KMZ_META_KEY = "kmz_meta_v1";
    const LS_ME_ICON_KEY = "me_icon_v1";

    function safeJsonParse(str, fallback){
      try{ return JSON.parse(str); }catch(e){ return fallback; }
    }

    function openKmzDb(){
      return new Promise((resolve,reject)=>{
        const req = indexedDB.open(KMZ_DB_NAME, KMZ_DB_VERSION);
        req.onupgradeneeded = ()=>{
          const db = req.result;
          if(!db.objectStoreNames.contains(KMZ_STORE)){
            const store = db.createObjectStore(KMZ_STORE, { keyPath: "id" });
            store.createIndex("addedAt","addedAt",{unique:false});
          }
        };
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      });
    }

    async function idbPutKmz(id, fileName, arrayBuffer){
      const db = await openKmzDb();
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(KMZ_STORE, "readwrite");
        tx.objectStore(KMZ_STORE).put({ id, fileName, buffer: arrayBuffer, addedAt: Date.now() });
        tx.oncomplete = ()=>{ db.close(); resolve(true); };
        tx.onerror = ()=>{ const err=tx.error; db.close(); reject(err); };
      });
    }

    async function idbGetAllKmz(){
      const db = await openKmzDb();
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(KMZ_STORE, "readonly");
        const req = tx.objectStore(KMZ_STORE).getAll();
        req.onsuccess = ()=>{ const rows=req.result||[]; db.close(); resolve(rows); };
        req.onerror = ()=>{ const err=req.error; db.close(); reject(err); };
      });
    }


    async function idbDeleteKmz(id){
      const db = await openKmzDb();
      return new Promise((resolve,reject)=>{
        const tx = db.transaction(KMZ_STORE, "readwrite");
        tx.objectStore(KMZ_STORE).delete(id);
        tx.oncomplete = ()=>{ db.close(); resolve(true); };
        tx.onerror = ()=>{ const err=tx.error; db.close(); reject(err); };
      });
    }

    function saveKmzMeta(){
      const meta = kmzLayersList.map(e=>({
        label: e.label,
        fileName: e.fileName,
        color: e.color,
        iconUrl: e.iconUrl || "",
        iconSize: e.iconSize || 10
      }));
      try{ localStorage.setItem(LS_KMZ_META_KEY, JSON.stringify(meta)); }catch(e){}
    }

    function loadKmzMeta(){
      try{ return safeJsonParse(localStorage.getItem(LS_KMZ_META_KEY), []); }catch(e){ return []; }
    }

    function saveMeIconPrefs(){
      const prefs = { url: meIconUrl || "", size: meIconSize || 14 };
      try{ localStorage.setItem(LS_ME_ICON_KEY, JSON.stringify(prefs)); }catch(e){}
    }

    function loadMeIconPrefs(){
      try{ return safeJsonParse(localStorage.getItem(LS_ME_ICON_KEY), null); }catch(e){ return null; }
    }


    // Buscador + rutas
    const searchBox = document.getElementById("searchBox");
    const resultsEl = document.getElementById("results");
    const clearRouteBtn = document.getElementById("clearRouteBtn");
    const searchHint = document.getElementById("searchHint");

    // Cambiar icono de puntos por KMZ
    const kmzSelect = document.getElementById("kmzSelect");
    const iconUrlInput = document.getElementById("iconUrl");
    const applyIconBtn = document.getElementById("applyIconBtn");
    const resetIconBtn = document.getElementById("resetIconBtn");
    const sizeUpBtn = document.getElementById("sizeUpBtn");
    const sizeDownBtn = document.getElementById("sizeDownBtn");
    const meIconUrlInput = document.getElementById("meIconUrl");
    const applyMeIconBtn = document.getElementById("applyMeIconBtn");
    const meSizeUpBtn = document.getElementById("meSizeUpBtn");
    const meSizeDownBtn = document.getElementById("meSizeDownBtn");

        const deleteKmzBtn = document.getElementById("deleteKmzBtn");
// √çndice de puntos (placemarks) por nombre
    // { name, latlng, marker, kmzLabel }
    const poiIndex = [];

    // √çndice de tracks/paths por KMZ
    // { kmzLabel, latlngs: [L.LatLng, ...] }  (para LineString) y MultiLineString como m√∫ltiples entradas
    const trackIndex = [];

    // Ruta actual (Leaflet Routing Machine)
    let routingControl = null;

    // L√≠nea gu√≠a por track (KMZ)
    let trackGuideLine = null;

    function clearRoute(){
      if(routingControl){
        map.removeControl(routingControl);
        routingControl = null;
      }
      if(trackGuideLine){
        map.removeLayer(trackGuideLine);
        trackGuideLine = null;
      }
    }
    clearRouteBtn.addEventListener("click", clearRoute);

    function normalize(s){
      return (s ?? "").toString().trim();
    }

    // --- Geometr√≠a para "guiado por track" ---
    function proj(ll){
      // Proyecci√≥n a coordenadas planas (EPSG:3857) usando el CRS del mapa
      return map.options.crs.project(ll);
    }

    function closestPointOnSegment(P, A, B){
      const ax=A.x, ay=A.y, bx=B.x, by=B.y, px=P.x, py=P.y;
      const abx = bx-ax, aby = by-ay;
      const apx = px-ax, apy = py-ay;
      const ab2 = abx*abx + aby*aby;
      let t = ab2 ? (apx*abx + apy*aby)/ab2 : 0;
      t = Math.max(0, Math.min(1, t));
      return { x: ax + t*abx, y: ay + t*aby, t };
    }

    function closestPointOnPolyline(latlngs, targetLatLng){
      // Devuelve: { idx, t, closestLatLng, distMeters }
      if(!latlngs || latlngs.length < 2) return null;
      const P = proj(targetLatLng);
      let best = null;
      for(let i=0;i<latlngs.length-1;i++){
        const A = proj(latlngs[i]);
        const B = proj(latlngs[i+1]);
        const cp = closestPointOnSegment(P, A, B);
        const dx = P.x - cp.x, dy = P.y - cp.y;
        const d = Math.hypot(dx, dy);
        if(!best || d < best.d){
          best = { i, t: cp.t, x: cp.x, y: cp.y, d };
        }
      }
      if(!best) return null;
      const ll = map.options.crs.unproject(L.point(best.x, best.y));
      // Distancia en metros aproximada (en EPSG:3857 ya est√° en metros)
      return { idx: best.i, t: best.t, closestLatLng: ll, distMeters: best.d };
    }

    function extractSubPolyline(latlngs, a, b){
      // a/b: { idx, t, closestLatLng }
      if(!latlngs || latlngs.length < 2 || !a || !b) return null;

      // Ordenar en el sentido del polyline (a -> b)
      const aPos = a.idx + a.t;
      const bPos = b.idx + b.t;

      const forward = aPos <= bPos;
      const start = forward ? a : b;
      const end   = forward ? b : a;

      const out = [];
      out.push(start.closestLatLng);

      // A√±ade v√©rtices intermedios completos
      for(let i = start.idx + 1; i <= end.idx; i++){
        out.push(latlngs[i]);
      }

      // Reemplaza √∫ltimo por el punto final proyectado
      out[out.length - 1] = end.closestLatLng;

      return forward ? out : out.reverse();
    }

    function pickBestTrack(fromLatLng, toLatLng){
      // Selecciona el track cuya suma de distancias a ambos puntos sea m√≠nima
      if(!trackIndex.length) return null;
      let best = null;
      for(const tr of trackIndex){
        const c1 = closestPointOnPolyline(tr.latlngs, fromLatLng);
        const c2 = closestPointOnPolyline(tr.latlngs, toLatLng);
        if(!c1 || !c2) continue;
        const score = c1.distMeters + c2.distMeters;
        if(!best || score < best.score){
          best = { track: tr, from: c1, to: c2, score };
        }
      }
      return best;
    }

    function setResultsVisible(v){
      resultsEl.style.display = v ? "block" : "none";
    }

    function renderResults(items){
      resultsEl.innerHTML = "";
      if(!items.length){
        setResultsVisible(false);
        return;
      }
      const frag = document.createDocumentFragment();
      items.slice(0, 80).forEach((it)=>{
        const div = document.createElement("div");
        div.className = "result-item";
        div.innerHTML = `<b>${it.name || "Sin nombre"}</b><br/><span class="muted">${it.kmzLabel}</span>`;
        div.addEventListener("click", ()=>{
          setResultsVisible(false);
          searchBox.blur();

          // centrar y abrir popup si existe
          map.setView(it.latlng, Math.max(map.getZoom(), 17));
          if(it.marker && it.marker.openPopup) it.marker.openPopup();

          if(!lastLatLng){
            
            return;
          }

          clearRoute();

          // Guiado por track (KMZ): busca la l√≠nea m√°s cercana a tu posici√≥n y al punto seleccionado
          const best = pickBestTrack(lastLatLng, it.latlng);
          let lineLatLngs = null;

          if(best){
            lineLatLngs = extractSubPolyline(best.track.latlngs, best.from, best.to);
          }

          // Si no hay tracks, dibuja l√≠nea directa como fallback
          if(!lineLatLngs){
            lineLatLngs = [ lastLatLng, it.latlng ];
          }

          trackGuideLine = L.polyline(lineLatLngs, {
            weight: 6,
            opacity: 0.85
          }).addTo(map);

          // Ajusta vista al tramo (sin cambiar la l√≥gica de follow)
          try{
            const b = trackGuideLine.getBounds && trackGuideLine.getBounds();
            b && b.isValid && b.isValid() && map.fitBounds(b.pad(0.2));
          }catch(e){}

          
        });
        frag.appendChild(div);
      });
      resultsEl.appendChild(frag);
      setResultsVisible(true);
    }

    function doSearch(){
      const q = normalize(searchBox.value).toLowerCase();
      if(!poiIndex.length){
        
        setResultsVisible(false);
        return;
      }
      if(!q){
        
        setResultsVisible(false);
        return;
      }
      const hits = poiIndex.filter(p => (p.name || "").toLowerCase().includes(q));
      
      renderResults(hits);
    }

    searchBox.addEventListener("input", doSearch);
    searchBox.addEventListener("focus", doSearch);

    // Cierra resultados al clicar fuera
    document.addEventListener("click", (e)=>{
      const inHud = e.target.closest && e.target.closest(".hud");
      if(!inHud) setResultsVisible(false);
    });

    // --- Minimizar / expandir HUD ---
    function setHudMinimized(min){
      if(!hudEl || !hudToggleBtn) return;
      hudEl.classList.toggle("minimized", !!min);
      hudToggleBtn.textContent = min ? "‚ñ∏" : "‚ñæ";
      hudToggleBtn.setAttribute("aria-label", min ? "Expandir panel" : "Minimizar panel");
      hudToggleBtn.title = min ? "Expandir / mostrar" : "Minimizar / ocultar";
      try{ localStorage.setItem("hud_minimized_v1", min ? "1" : "0"); }catch(e){}
    }

    // Restaurar estado del panel
    try{
      const v = localStorage.getItem("hud_minimized_v1");
      if(v === "1") setHudMinimized(true);
    }catch(e){}

    if(hudToggleBtn){
      hudToggleBtn.addEventListener("click", (ev)=>{
        ev.preventDefault();
        ev.stopPropagation();
        setHudMinimized(!hudEl.classList.contains("minimized"));
      });
    }



    // Abrir selector de archivos SIN contrase√±a
    chooseFilesBtn.addEventListener("click", () => {
      kmzInput.click();
    });

    const map = L.map("map").setView([40.4168, -3.7038], 6);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19
    }).addTo(map);

    const meIcon = L.divIcon({
      className: "",
      html: '<div style="width:14px;height:14px;border-radius:50%;background:#2b6cff;border:3px solid #fff;box-shadow:0 2px 10px rgba(0,0,0,.35);"></div>',
      iconSize:[14,14],
      iconAnchor:[7,7]
    });

    // Iconos de KMZ: sin imagen, un punto (c√≠rculo) de color distinto por cada KMZ
    // 30% m√°s peque√±o que el punto de tu ubicaci√≥n (14px -> ~10px)

    function makeMeImageIcon(url, size){
      return L.icon({
        iconUrl: url,
        iconSize: [size, size],
        iconAnchor: [size/2, size/2],
        popupAnchor: [0, -size/2],
        className: "me-img-icon"
      });
    }

    function makeMeRotIcon(url, size){
      // Un icono rotatable: flecha siempre presente; si hay imagen, se muestra en el centro.
      const s = Math.max(10, Math.min(96, Math.round(size || 14)));
      const imgHtml = url ? `
        <span class="me-rot-img" style="width:${s}px;height:${s}px;">
          <img class="me-img" src="${url}" style="width:${s}px;height:${s}px;" />
        </span>` : ``;

      return L.divIcon({
        className: "me-rot-icon",
        html: `<div class="me-rot-wrap">
                 <span class="me-rot-arrow"></span>
                 ${imgHtml || `<span class="me-rot-dot"></span>`}
               </div>`,
        iconSize: [18,18],
        iconAnchor: [9,9]
      });
    }

    function setMeBearingDegrees(deg){
      if(!myMarker) return;
      const el = myMarker.getElement && myMarker.getElement();
      if(!el) return;
      const wrap = el.querySelector && el.querySelector(".me-rot-wrap");
      if(!wrap) return;
      const d = (typeof deg === "number" && isFinite(deg)) ? deg : 0;
      wrap.style.transform = `rotate(${d}deg)`;
    }


    function kmzColorForIndex(i){
      // colores bien separados usando el √°ngulo √°ureo
      const hue = (i * 137.508) % 360;
      return `hsl(${hue} 85% 50%)`;
    }

    function makeKmzDotIcon(color){
      const size = 10;   // ~30% menos que 14px
      const border = 2;  // borde blanco para contraste
      return L.divIcon({
        className: "",
        html: `<div style="
          width:${size}px;height:${size}px;border-radius:50%;
          background:${color};
          border:${border}px solid #fff;
          box-shadow:0 2px 10px rgba(0,0,0,.25);
        "></div>`,
        iconSize:[size, size],
        iconAnchor:[size/2, size/2]
      });
    }

    function makeKmzImageIcon(url, size){
      // En algunos casos conviene cache-bust; lo dejamos al usuario
      return L.icon({
        iconUrl: url,
        iconSize: [size, size],
        iconAnchor: [size/2, size/2],
        popupAnchor: [0, -size/2],
        className: "kmz-img-icon"
      });
    }

    const overlays = {};
    const layersControl = L.control.layers({}, overlays, { collapsed:false }).addTo(map);
    // Lista de KMZ cargados: { label, fileName, color, layer, markers:[] }
    const kmzLayersList = [];
    let kmzCounter = 1;

    let myMarker=null, myAccuracyCircle=null, lastLatLng=null, firstFix=true;
    let meIconUrl = "";
    let meIconSize = 14;

    // Restaurar icono de "mi ubicaci√≥n"
    const mePrefs = loadMeIconPrefs();
    if(mePrefs && typeof mePrefs === "object"){
      if(typeof mePrefs.url === "string") meIconUrl = mePrefs.url;
      if(typeof mePrefs.size === "number" && isFinite(mePrefs.size)) meIconSize = Math.max(6, Math.min(96, Math.round(mePrefs.size)));
    }


    function updateMyLocation(pos){
      const {latitude, longitude, accuracy} = pos.coords;
      lastLatLng = L.latLng(latitude, longitude);

      if(!myMarker){
        const icon = makeMeRotIcon(meIconUrl, meIconSize);
        myMarker = L.marker(lastLatLng,{icon}).addTo(map);
        myAccuracyCircle = L.circle(lastLatLng,{
          radius:accuracy,
          weight:1,
          fillOpacity:.1
        }).addTo(map);
      }else{
        myMarker.setLatLng(lastLatLng);
        myMarker.setIcon(makeMeRotIcon(meIconUrl, meIconSize));
        myAccuracyCircle.setLatLng(lastLatLng);
        myAccuracyCircle.setRadius(accuracy);
      }

      // Orientaci√≥n: si "seguirme" est√° activo y el dispositivo aporta heading, rota el marcador (estilo navegador)
      const hd = (pos && pos.coords) ? pos.coords.heading : null; // grados (0=norte)
      if(followChk.checked && typeof hd === "number" && isFinite(hd)){
        setMeBearingDegrees(hd);
      }

      

      if(firstFix){
        map.setView(lastLatLng,17);
        firstFix=false;
      }else if(followChk.checked){
        map.panTo(lastLatLng, { animate:true });
      }
    }

    function geoError(err){
      
    }

    if(navigator.geolocation){
      navigator.geolocation.watchPosition(updateMyLocation, geoError, {
        enableHighAccuracy:true,
        maximumAge:1000,
        timeout:10000
      });
    }else{
      
    }

    recenterBtn.onclick = () =>
      lastLatLng && map.setView(lastLatLng, Math.max(map.getZoom(), 17));

    fitAllBtn.onclick = ()=>{
      let bounds=null;

      kmzLayersList.forEach(({layer})=>{
        if(map.hasLayer(layer)){
          const b = layer.getBounds?.();
          if(b && b.isValid && b.isValid())
            bounds = bounds ? bounds.extend(b) : b;
        }
      });

      if(lastLatLng){
        const b = L.latLngBounds([lastLatLng,lastLatLng]);
        bounds = bounds ? bounds.extend(b) : b;
      }

      bounds && bounds.isValid && bounds.isValid() &&
        map.fitBounds(bounds.pad(.2));
    };
    
    // --- Icono de MI ubicaci√≥n ---
    applyMeIconBtn.addEventListener("click", ()=>{
      const url = meIconUrlInput.value.trim();
      if(!url){
        meIconUrl = "";
        meIconSize = 14;
        myMarker && myMarker.setIcon(makeMeRotIcon("", meIconSize));
        saveMeIconPrefs();
        return;
      }
      meIconUrl = url;
      meIconSize = meIconSize || 14;
      myMarker && myMarker.setIcon(makeMeRotIcon(meIconUrl, meIconSize));
          saveMeIconPrefs();
    });

    meSizeUpBtn.addEventListener("click", ()=>{
      if(!meIconUrl) return;
      meIconSize += 5;
      myMarker && myMarker.setIcon(makeMeRotIcon(meIconUrl, meIconSize));
          saveMeIconPrefs();
    });

    meSizeDownBtn.addEventListener("click", ()=>{
      if(!meIconUrl) return;
      meIconSize = Math.max(5, meIconSize - 5);
      myMarker && myMarker.setIcon(makeMeRotIcon(meIconUrl, meIconSize));
          saveMeIconPrefs();
    });

    // --- Iconos por KMZ (URL directa) ---
    function getKmzEntryByLabel(label){
      return kmzLayersList.find(x => x.label === label);
    }

    function ensureKmzSelectEnabled(){
      const has = kmzLayersList.length > 0;
      kmzSelect.disabled = !has;
      if(has && !kmzSelect.value){
        kmzSelect.value = kmzLayersList[kmzLayersList.length - 1].label;
      }
    }

    function applyIconToKmz(label, iconUrl){
      const entry = getKmzEntryByLabel(label);
      if(!entry){
        return;
      }
      const url = (iconUrl || "").trim();
      if(!url){
        return;
      }

      entry.iconUrl = url;
      // si no hay tama√±o definido, usa el actual o 10
      entry.iconSize = (typeof entry.iconSize === "number" && isFinite(entry.iconSize)) ? entry.iconSize : 10;

      const icon = makeKmzImageIcon(url, entry.iconSize);
      entry.markers.forEach(m => m.setIcon(icon));
      saveKmzMeta();
    }

    function resetIconToDot(label){
      const entry = getKmzEntryByLabel(label);
      if(!entry){
        return;
      }
      const dot = makeKmzDotIcon(entry.color);
      entry.markers.forEach(m => m.setIcon(dot));
      entry.iconUrl = "";
      entry.iconSize = 10;
      saveKmzMeta();
    }

    applyIconBtn.addEventListener("click", ()=>{
      ensureKmzSelectEnabled();
      const label = kmzSelect.value;
      applyIconToKmz(label, iconUrlInput.value);
    });

    resetIconBtn.addEventListener("click", ()=>{
      ensureKmzSelectEnabled();
      const label = kmzSelect.value;
      resetIconToDot(label);
    });

    
    // Cambiar tama√±o del icono en pasos de 5px
    function resizeKmzIcon(label, delta){
      const entry = getKmzEntryByLabel(label);
      if(!entry || !entry.iconUrl){
        return;
      }
      entry.iconSize = Math.max(5, (entry.iconSize || 10) + delta);
      const icon = makeKmzImageIcon(entry.iconUrl, entry.iconSize);
      entry.markers.forEach(m => m.setIcon(icon));
      saveKmzMeta();
    }

    sizeUpBtn.addEventListener("click", ()=>{
      resizeKmzIcon(kmzSelect.value, +5);
    });

    sizeDownBtn.addEventListener("click", ()=>{
      resizeKmzIcon(kmzSelect.value, -5);
    });

    // Si cambias de KMZ en el selector, rellena el input con el icono actual (si existe)
    kmzSelect.addEventListener("change", ()=>{
      const entry = getKmzEntryByLabel(kmzSelect.value);
      iconUrlInput.value = entry?.iconUrl || "";
    });



    // --- Borrar KMZ seleccionado ---
    async function deleteSelectedKmz(){
      const label = kmzSelect.value;
      if(!label) return;

      const idx = kmzLayersList.findIndex(k => k.label === label);
      if(idx === -1) return;

      const entry = kmzLayersList[idx];

      // 1) Quitar del mapa
      if(entry.layer && map.hasLayer(entry.layer)){
        map.removeLayer(entry.layer);
      }

      // 2) Quitar del control de capas
      try{
        entry.layer && layersControl.removeLayer(entry.layer);
      }catch(e){}

      // 3) Quitar de overlays (por si se usa en el futuro)
      try{ delete overlays[label]; }catch(e){}

      // 4) Quitar POIs del √≠ndice de b√∫squeda
      for(let i = poiIndex.length - 1; i >= 0; i--){
        if(poiIndex[i].kmzLabel === label){
          poiIndex.splice(i, 1);
        }
      }


      // 4b) Quitar tracks del √≠ndice
      for(let i = trackIndex.length - 1; i >= 0; i--){
        if(trackIndex[i].kmzLabel === label){
          trackIndex.splice(i, 1);
        }
      }

      // 5) Borrar binario de IndexedDB
      try{ await idbDeleteKmz(label); }catch(e){}

      // 6) Quitar de la lista y guardar metadatos
      kmzLayersList.splice(idx, 1);
      saveKmzMeta();

      // 7) Quitar del selector
      if(kmzSelect){
        [...kmzSelect.options].forEach(o=>{
          if(o.value === label) o.remove();
        });
      }

      // 8) Reset UI
      kmzSelect.value = "";
      iconUrlInput.value = "";
      ensureKmzSelectEnabled();

      // Si hay un KMZ seleccionado tras el borrado, muestra su icono actual
      const newEntry = getKmzEntryByLabel(kmzSelect.value);
      if(newEntry) iconUrlInput.value = newEntry.iconUrl || "";
    }

    if(deleteKmzBtn){
      deleteKmzBtn.addEventListener("click", ()=>{
        const label = kmzSelect.value;
        if(!label) return;
        if(confirm("¬øBorrar este KMZ definitivamente?")){
          deleteSelectedKmz();
        }
      });
    }

    async function loadKmzData(fileName, arrayBuffer, meta){
      // Color e icono para ESTE KMZ
      const color = (meta && meta.color) ? meta.color : kmzColorForIndex(kmzCounter);
      const kmzDotIcon = makeKmzDotIcon(color);

      // Registro para poder cambiar el icono de este KMZ m√°s tarde
      const entry = {
        label: (meta && meta.label) ? meta.label : "",
        fileName,
        color,
        layer: null,
        markers: [],
        iconUrl: (meta && meta.iconUrl) ? meta.iconUrl : "",
        iconSize: (meta && meta.iconSize) ? meta.iconSize : 10
      };

      const zip = await JSZip.loadAsync(arrayBuffer);
      const kmlName = Object.keys(zip.files).find(n => n.toLowerCase().endsWith(".kml"));
      if(!kmlName) throw new Error("KMZ sin .kml interno");

      const dom = new DOMParser().parseFromString(await zip.files[kmlName].async("text"), "text/xml");
      const geojson = toGeoJSON.kml(dom);

      // Indexar tracks/paths (LineString / MultiLineString) para guiado visual
      try{
        const feats = (geojson && geojson.features) ? geojson.features : [];
        for(const f of feats){
          const g = f && f.geometry;
          if(!g) continue;
          if(g.type === "LineString" && Array.isArray(g.coordinates)){
            const latlngs = g.coordinates.map(c => L.latLng(c[1], c[0]));
            if(latlngs.length >= 2){
              trackIndex.push({ kmzLabel: entry.label || "", latlngs });
            }
          }else if(g.type === "MultiLineString" && Array.isArray(g.coordinates)){
            for(const part of g.coordinates){
              const latlngs = (part||[]).map(c => L.latLng(c[1], c[0]));
              if(latlngs.length >= 2){
                trackIndex.push({ kmzLabel: entry.label || "", latlngs });
              }
            }
          }
        }
      }catch(e){}

      // Si hay icono guardado, √∫salo desde el primer render
      const pointIcon = entry.iconUrl ? makeKmzImageIcon(entry.iconUrl, entry.iconSize) : kmzDotIcon;

      const layer = L.geoJSON(geojson,{
        pointToLayer:(feature,ll)=>{
          const marker = L.marker(ll,{icon: pointIcon});
          entry.markers.push(marker);
          const nm = (feature && feature.properties && feature.properties.name) ? String(feature.properties.name) : "";
          if(nm){
            poiIndex.push({ name: nm, latlng: ll, marker, kmzLabel: entry.label || "" });
          }
          return marker;
        }
      }).addTo(map);

      // Etiqueta
      const label = entry.label ? entry.label : `${kmzCounter++}. ${fileName}`;
      entry.label = label;
      entry.layer = layer;

      overlays[label] = layer;
      layersControl.addOverlay(layer, label);
      kmzLayersList.push(entry);

      // A√±adir al selector de KMZ
      if(kmzSelect){
        const opt = document.createElement("option");
        opt.value = label;
        opt.textContent = label;
        kmzSelect.appendChild(opt);
        kmzSelect.disabled = false;
        kmzSelect.value = label;
        iconUrlInput.value = "";
      }

      const b = layer.getBounds?.();
      if(b && b.isValid && b.isValid()) map.fitBounds(b.pad(.2));

      // Persistir metadatos (icono incluido)
      saveKmzMeta();
    }

    // Wrapper: carga desde archivo seleccionado por el usuario y lo guarda en IndexedDB
    async function loadKmzFile(file){
      const buf = await file.arrayBuffer();
      await loadKmzData(file.name, buf, null);

      // Guardar binario en IndexedDB usando la etiqueta reci√©n creada (√∫ltimo elemento)
      const last = kmzLayersList[kmzLayersList.length - 1];
      if(last && last.label){
        try{ await idbPutKmz(last.label, last.fileName, buf); }catch(e){}
      }
    }

    // Restaurar KMZ persistidos al abrir la app
    async function restorePersistedKmz(){
      const meta = loadKmzMeta();
      let rows = [];
      try{ rows = await idbGetAllKmz(); }catch(e){ rows = []; }

      const metaMap = new Map((meta||[]).map(m=>[m.label, m]));

      rows.sort((a,b)=>{
        const getN = (x)=>{
          const s = (x && x.id) ? String(x.id) : "";
          const m = s.match(/^(\d+)\./);
          return m ? parseInt(m[1],10) : null;
        };
        const na = getN(a), nb = getN(b);
        if(na!=null && nb!=null) return na-nb;
        if(na!=null) return -1;
        if(nb!=null) return 1;
        return (a.addedAt||0)-(b.addedAt||0);
      });

      let maxN = 0;
      for(const r of rows){
        const m = metaMap.get(r.id) || { label: r.id, fileName: r.fileName };
        const mm = String(m.label||"").match(/^(\d+)\./);
        if(mm){
          const n = parseInt(mm[1],10);
          if(n > maxN) maxN = n;
        }
        try{ await loadKmzData(r.fileName, r.buffer, m); }catch(e){}
      }
      if(maxN > 0) kmzCounter = maxN + 1;
    }




    // Al abrir la app, restaura KMZ e iconos persistidos
    (async ()=>{
      try{ await restorePersistedKmz(); }
      catch(e){}
      ensureKmzSelectEnabled();
      // Rellena el input del icono con el estado del KMZ seleccionado
      const entry = getKmzEntryByLabel(kmzSelect.value);
      if(entry) iconUrlInput.value = entry.iconUrl || "";
      // Restaurar UI del icono de "mi ubicaci√≥n"
      if(meIconUrlInput){ meIconUrlInput.value = meIconUrl || ""; }
    })();

    kmzInput.onchange = async e=>{
      const files = Array.from(e.target.files || []);
      for(const f of files){
        try { await loadKmzFile(f); }
        catch(err){
          
        }
      }
      kmzInput.value = "";
    };
  </script>
<script src="timex_visor_bridge.js"></script>
</body>
</html>
